//! Contains the data structures and functions for querying & filling the address information needed
//! in RDMA communication, like [`Gid`] and [`AddressHandleAttribute`].
use libc::IF_NAMESIZE;
use rdma_mummy_sys::{
    ibv_ah, ibv_ah_attr, ibv_create_ah, ibv_gid, ibv_gid_entry, ibv_global_route, ibv_grh, IBV_GID_TYPE_IB,
    IBV_GID_TYPE_ROCE_V1, IBV_GID_TYPE_ROCE_V2,
};
use serde::{Deserialize, Serialize};
use std::ffi::CStr;
use std::io;
use std::ptr;
use std::ptr::NonNull;
use std::sync::Arc;
use std::{fmt, mem::MaybeUninit, net::Ipv6Addr};

use super::protection_domain::ProtectionDomain;

/// Error returned by [`ProtectionDomain::create_ah`] for creating a new RDMA Address Handle.
#[derive(Debug, thiserror::Error)]
#[error("failed to create address handle")]
#[non_exhaustive]
pub struct CreateAddressHandleError(#[from] pub CreateAddressHandleErrorKind);

/// The enum type for [`CreateAddressHandleError`].
#[derive(Debug, thiserror::Error)]
#[error(transparent)]
#[non_exhaustive]
pub enum CreateAddressHandleErrorKind {
    Ibverbs(#[from] io::Error),
}

/// Error returned when constructing a [`GlobalRoutingHeader`] from invalid input.
#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum GlobalRoutingHeaderError {
    /// The provided slice is smaller than the GRH header size.
    #[error("raw slice length {actual} is smaller than required {expected} bytes")]
    SliceTooSmall { actual: usize, expected: usize },
}

/// GID is a global identifier for sending packets between different subnets. For RoCEv1 and RoCEv2,
/// it would correspond to an IP address set up on the ethernet device.
#[derive(Default, Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Gid {
    pub raw: [u8; 16],
}

impl AsMut<ibv_gid> for Gid {
    fn as_mut(&mut self) -> &mut ibv_gid {
        unsafe { &mut *self.raw.as_mut_ptr().cast::<ibv_gid>() }
    }
}

impl From<ibv_gid> for Gid {
    fn from(gid: ibv_gid) -> Self {
        Self {
            raw: unsafe { gid.raw },
        }
    }
}

impl From<Gid> for ibv_gid {
    fn from(mut gid: Gid) -> Self {
        *gid.as_mut()
    }
}

impl From<Gid> for Ipv6Addr {
    fn from(gid: Gid) -> Self {
        Ipv6Addr::from(gid.raw)
    }
}

impl From<Ipv6Addr> for Gid {
    fn from(addr: Ipv6Addr) -> Self {
        Gid { raw: addr.octets() }
    }
}

impl fmt::Display for Gid {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for (i, &byte) in self.raw.iter().enumerate() {
            if i > 0 && i % 2 == 0 {
                write!(f, ":")?;
            }
            write!(f, "{byte:02x}")?;
        }
        Ok(())
    }
}

impl Gid {
    /// Check if this GID is all zero.
    pub fn is_zero(&self) -> bool {
        let (prefix, aligned, suffix) = unsafe { self.raw.align_to::<u128>() };

        prefix.iter().all(|&x| x == 0) && suffix.iter().all(|&x| x == 0) && aligned.iter().all(|&x| x == 0)
    }

    /// Check if this GID is a unicast link local one, for example, a GID starts with `fe80::`, it's
    /// usually generated by system automatically.
    pub fn is_unicast_link_local(&self) -> bool {
        self.raw[0] == 0xfe && self.raw[1] & 0xc0 == 0x80
    }
}

/// The type of a GID, determines the unlerlying wire format for sending packets. For communication
/// between two endpoints, **user should specify the same type of GID on each side by selecting the
/// correct GID index**.
#[repr(u32)]
#[derive(PartialEq, Eq, Clone, Copy, Debug, Serialize, Deserialize)]
pub enum GidType {
    InfiniBand = IBV_GID_TYPE_IB,
    RoceV1 = IBV_GID_TYPE_ROCE_V1,
    RoceV2 = IBV_GID_TYPE_ROCE_V2,
}

impl From<u32> for GidType {
    fn from(gid_type: u32) -> Self {
        match gid_type {
            IBV_GID_TYPE_IB => GidType::InfiniBand,
            IBV_GID_TYPE_ROCE_V1 => GidType::RoceV1,
            IBV_GID_TYPE_ROCE_V2 => GidType::RoceV2,
            _ => panic!("Unknown Gid type: {gid_type}"),
        }
    }
}

/// A GID entry that contains all information about a GID, including GID address, GID index, port
/// number, GID type and the ethernet device index.
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct GidEntry(pub(crate) ibv_gid_entry);

impl Default for GidEntry {
    fn default() -> Self {
        GidEntry(ibv_gid_entry {
            gid: Gid::default().into(),
            gid_index: 0,
            port_num: 1,
            gid_type: 0,
            ndev_ifindex: 0,
        })
    }
}

impl GidEntry {
    /// Get the GID index.
    #[inline]
    pub fn gid_index(&self) -> u32 {
        self.0.gid_index
    }

    /// Get the Infiniband device port number.
    #[inline]
    pub fn port_num(&self) -> u32 {
        self.0.port_num
    }

    /// Get the GID type.
    #[inline]
    pub fn gid_type(&self) -> GidType {
        self.0.gid_type.into()
    }

    /// Get the ethernet device index.
    #[inline]
    pub fn netdev_index(&self) -> u32 {
        self.0.ndev_ifindex
    }

    /// Get the ethernet device name.
    pub fn netdev_name(&self) -> Result<String, String> {
        let mut buf = vec![0u8; IF_NAMESIZE];

        let return_buf = unsafe { libc::if_indextoname(self.netdev_index(), buf.as_mut_ptr().cast()) };

        if return_buf.is_null() {
            return Err(format!("get netdev name failed {:?}", io::Error::last_os_error()));
        }

        Ok(CStr::from_bytes_until_nul(buf.as_slice())
            .unwrap()
            .to_str()
            .unwrap()
            .to_owned())
    }

    /// Get the GID address.
    #[inline]
    pub fn gid(&self) -> Gid {
        unsafe { Gid { raw: self.0.gid.raw } }
    }
}

/// The address handle is a structure that stores and manages the information needed to communicate
/// with a remote endpoint. It's used for [`QueuePair::modify`] to specify the address information
/// for [`ReliableConnection`] and [`UnreliableConnection`] QP, or used for [`PostSendGuard`] on an
/// [`UnreliableDatagram`] QP (Work In Progress).
///
/// [`QueuePair::modify`]: crate::ibverbs::queue_pair::QueuePair::modify
/// [`ReliableConnection`]: crate::ibverbs::queue_pair::QueuePairType::ReliableConnection
/// [`UnreliableConnection`]: crate::ibverbs::queue_pair::QueuePairType::UnreliableConnection
/// [`PostSendGuard`]: crate::ibverbs::queue_pair::PostSendGuard
/// [`UnreliableDatagram`]: crate::ibverbs::queue_pair::QueuePairType::UnreliableDatagram
///
pub struct AddressHandleAttribute {
    pub(crate) attr: ibv_ah_attr,
}

impl Default for AddressHandleAttribute {
    fn default() -> Self {
        Self::new()
    }
}

impl AddressHandleAttribute {
    pub fn new() -> Self {
        AddressHandleAttribute {
            attr: unsafe { MaybeUninit::zeroed().assume_init() },
        }
    }

    /// Setup the destination LID. If the destination is on the same subnet, the LID would be the
    /// one of port to which the subnet delivers the packets to. If the destination is on another
    /// subnet, the LID would be the one of the Router.
    pub fn setup_dest_lid(&mut self, dest_lid: u16) -> &mut Self {
        self.attr.dlid = dest_lid;
        self
    }

    /// Setup the service level to be used, 4 bits only.
    pub fn setup_service_level(&mut self, sl: u8) -> &mut Self {
        self.attr.sl = sl;
        self
    }

    /// Setup the physical port that the packets will be sent from, starts from `1`.
    pub fn setup_port(&mut self, port_num: u8) -> &mut Self {
        self.attr.port_num = port_num;
        self
    }

    /// Setup the attributes of the Global Routing Headers (GRH), it's useful when sending packets
    /// to another subnet or to a multicast group. You could treat this as setting up the source IP
    /// (by specifying the `src_gid_index`) and destination IP (by specifying the `dest_gid`).
    pub fn setup_grh(
        &mut self, dest_gid: &Gid, flow_label: u32, src_gid_index: u8, hop_limit: u8, traffic_class: u8,
    ) -> &mut Self {
        self.attr.grh = ibv_global_route {
            dgid: (*dest_gid).into(),
            flow_label,
            sgid_index: src_gid_index,
            hop_limit,
            traffic_class,
        };
        self.attr.is_global = 1;
        self
    }

    /// Setup the destination GID field in the GRH.
    pub fn setup_grh_dest_gid(&mut self, dest_gid: &Gid) -> &mut Self {
        self.attr.grh.dgid = (*dest_gid).into();
        self.attr.is_global = 1;
        self
    }

    /// Setup the `src_gid_index` field in the GRH.
    pub fn setup_grh_src_gid_index(&mut self, src_gid_index: u8) -> &mut Self {
        self.attr.grh.sgid_index = src_gid_index;
        self.attr.is_global = 1;
        self
    }

    /// Setup the `hop_limit` field in the GRH.
    pub fn setup_grh_hop_limit(&mut self, hop_limit: u8) -> &mut Self {
        self.attr.grh.hop_limit = hop_limit;
        self.attr.is_global = 1;
        self
    }
}

pub struct AddressHandle {
    pub(crate) handle: NonNull<ibv_ah>,
    pub(crate) _pd: Arc<ProtectionDomain>,
}

impl AddressHandle {
    pub fn new(pd: Arc<ProtectionDomain>, attr: &mut AddressHandleAttribute) -> Result<Self, CreateAddressHandleError> {
        let pd_ptr = unsafe { pd.pd() };
        let ah = unsafe { ibv_create_ah(pd_ptr.as_ptr(), &mut attr.attr as *mut _) };

        Ok(AddressHandle {
            handle: NonNull::new(ah).ok_or::<CreateAddressHandleError>(
                CreateAddressHandleErrorKind::Ibverbs(io::Error::last_os_error()).into(),
            )?,
            _pd: pd,
        })
    }

    /// # Safety
    ///
    /// Return the handle of address handle.
    /// We mark this method unsafe because the lifetime of `ibv_ah` is not associated
    /// with the return value.
    pub unsafe fn ah(&self) -> NonNull<ibv_ah> {
        self.handle
    }
}

/// Size in bytes of a Global Routing Header.
pub const GRH_HEADER_LEN: usize = 40;

/// A read/write wrapper around a Global Routing Header buffer.
///
/// This generic wrapper allows zero-copy access to GRH fields directly from a byte buffer,
/// following the smoltcp packet wrapper pattern.
#[derive(Debug)]
pub struct GlobalRoutingHeader<T: AsRef<[u8]>> {
    buffer: T,
}

// Field byte offsets within the GRH
mod grh_field {
    use std::ops::Range;

    pub const VERSION_TCLASS_FLOW: Range<usize> = 0..4;
    pub const PAYLOAD_LENGTH: Range<usize> = 4..6;
    pub const NEXT_HEADER: usize = 6;
    pub const HOP_LIMIT: usize = 7;
    pub const SOURCE_GID: Range<usize> = 8..24;
    pub const DESTINATION_GID: Range<usize> = 24..40;
}

impl<T: AsRef<[u8]>> GlobalRoutingHeader<T> {
    /// Create a raw octet buffer with a Global Routing Header structure.
    ///
    /// # Panics
    ///
    /// Accessor methods will panic if the buffer is smaller than [`GRH_HEADER_LEN`].
    /// Use [`new_checked`](Self::new_checked) if the buffer length is not guaranteed.
    pub const fn new_unchecked(buffer: T) -> Self {
        GlobalRoutingHeader { buffer }
    }

    /// Shorthand for a combination of [`new_unchecked`](Self::new_unchecked) and
    /// [`check_len`](Self::check_len).
    pub fn new_checked(buffer: T) -> Result<Self, GlobalRoutingHeaderError> {
        let header = Self::new_unchecked(buffer);
        header.check_len()?;
        Ok(header)
    }

    /// Ensure that no accessor method will panic if called.
    /// Returns `Err` if the buffer is too short.
    pub fn check_len(&self) -> Result<(), GlobalRoutingHeaderError> {
        let len = self.buffer.as_ref().len();
        if len < GRH_HEADER_LEN {
            return Err(GlobalRoutingHeaderError::SliceTooSmall {
                actual: len,
                expected: GRH_HEADER_LEN,
            });
        }
        Ok(())
    }

    /// Consume the header wrapper, returning the underlying buffer.
    pub fn into_inner(self) -> T {
        self.buffer
    }

    /// Return a reference to the underlying buffer.
    pub fn buffer(&self) -> &[u8] {
        self.buffer.as_ref()
    }

    /// Return a const pointer to the header buffer, suitable for FFI.
    ///
    /// The pointer is valid for the lifetime of the underlying buffer.
    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.buffer.as_ref().as_ptr()
    }

    /// Copy the header bytes into a newly allocated `ibv_grh` structure.
    ///
    /// This is useful for FFI calls that require an owned `ibv_grh`.
    #[inline]
    pub fn grh(&self) -> ibv_grh {
        unsafe { ptr::read_unaligned(self.buffer.as_ref().as_ptr().cast::<ibv_grh>()) }
    }

    /// Get the GRH version number (4 bits).
    #[inline]
    pub fn version(&self) -> u8 {
        (self.buffer.as_ref()[grh_field::VERSION_TCLASS_FLOW.start] >> 4) & 0x0f
    }

    /// Get the IPv6 traffic class encoded in the header (8 bits).
    #[inline]
    pub fn traffic_class(&self) -> u8 {
        let data = &self.buffer.as_ref()[grh_field::VERSION_TCLASS_FLOW];
        ((data[0] & 0x0f) << 4) | ((data[1] >> 4) & 0x0f)
    }

    /// Get the IPv6-style flow label carried in the header (20 bits).
    #[inline]
    pub fn flow_label(&self) -> u32 {
        let data = &self.buffer.as_ref()[grh_field::VERSION_TCLASS_FLOW];
        u32::from_be_bytes([0, data[1] & 0x0f, data[2], data[3]])
    }

    /// Payload length in bytes following the GRH.
    #[inline]
    pub fn payload_length(&self) -> u16 {
        let data = &self.buffer.as_ref()[grh_field::PAYLOAD_LENGTH];
        u16::from_be_bytes([data[0], data[1]])
    }

    /// Next header identifier.
    #[inline]
    pub fn next_header(&self) -> u8 {
        self.buffer.as_ref()[grh_field::NEXT_HEADER]
    }

    /// Hop limit value for the packet.
    #[inline]
    pub fn hop_limit(&self) -> u8 {
        self.buffer.as_ref()[grh_field::HOP_LIMIT]
    }

    /// Source GID extracted from the header.
    #[inline]
    pub fn source_gid(&self) -> Gid {
        let mut raw = [0u8; 16];
        raw.copy_from_slice(&self.buffer.as_ref()[grh_field::SOURCE_GID]);
        Gid { raw }
    }

    /// Destination GID extracted from the header.
    #[inline]
    pub fn destination_gid(&self) -> Gid {
        let mut raw = [0u8; 16];
        raw.copy_from_slice(&self.buffer.as_ref()[grh_field::DESTINATION_GID]);
        Gid { raw }
    }
}

impl<T: AsRef<[u8]> + AsMut<[u8]>> GlobalRoutingHeader<T> {
    /// Return a mutable reference to the underlying buffer.
    pub fn buffer_mut(&mut self) -> &mut [u8] {
        self.buffer.as_mut()
    }

    /// Return a mutable pointer to the header buffer, suitable for FFI.
    ///
    /// The pointer is valid for the lifetime of the underlying buffer.
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut u8 {
        self.buffer.as_mut().as_mut_ptr()
    }

    /// Set the GRH version number (4 bits).
    #[inline]
    pub fn setup_version(&mut self, value: u8) {
        let data = &mut self.buffer.as_mut()[grh_field::VERSION_TCLASS_FLOW.start];
        *data = (*data & 0x0f) | ((value & 0x0f) << 4);
    }

    /// Set the IPv6 traffic class (8 bits).
    #[inline]
    pub fn setup_traffic_class(&mut self, value: u8) {
        let data = &mut self.buffer.as_mut()[grh_field::VERSION_TCLASS_FLOW];
        data[0] = (data[0] & 0xf0) | ((value >> 4) & 0x0f);
        data[1] = (data[1] & 0x0f) | ((value & 0x0f) << 4);
    }

    /// Set the IPv6-style flow label (20 bits).
    #[inline]
    pub fn setup_flow_label(&mut self, value: u32) {
        let data = &mut self.buffer.as_mut()[grh_field::VERSION_TCLASS_FLOW];
        let bytes = value.to_be_bytes();
        data[1] = (data[1] & 0xf0) | (bytes[1] & 0x0f);
        data[2] = bytes[2];
        data[3] = bytes[3];
    }

    /// Set the payload length.
    #[inline]
    pub fn setup_payload_length(&mut self, value: u16) {
        let bytes = value.to_be_bytes();
        self.buffer.as_mut()[grh_field::PAYLOAD_LENGTH].copy_from_slice(&bytes);
    }

    /// Set the next header identifier.
    #[inline]
    pub fn setup_next_header(&mut self, value: u8) {
        self.buffer.as_mut()[grh_field::NEXT_HEADER] = value;
    }

    /// Set the hop limit.
    #[inline]
    pub fn setup_hop_limit(&mut self, value: u8) {
        self.buffer.as_mut()[grh_field::HOP_LIMIT] = value;
    }

    /// Set the source GID.
    #[inline]
    pub fn setup_source_gid(&mut self, gid: &Gid) {
        self.buffer.as_mut()[grh_field::SOURCE_GID].copy_from_slice(&gid.raw);
    }

    /// Set the destination GID.
    #[inline]
    pub fn setup_destination_gid(&mut self, gid: &Gid) {
        self.buffer.as_mut()[grh_field::DESTINATION_GID].copy_from_slice(&gid.raw);
    }
}

#[cfg(test)]
mod tests {
    use super::{Gid, GlobalRoutingHeader, GlobalRoutingHeaderError, GRH_HEADER_LEN};
    use rdma_mummy_sys::{ibv_gid, ibv_grh};
    use rstest::rstest;
    use std::net::Ipv6Addr;
    use std::str::FromStr;

    #[test]
    fn test_grh_header_len_matches_ibv_grh_size() {
        assert_eq!(GRH_HEADER_LEN, std::mem::size_of::<ibv_grh>());
    }

    #[rstest]
    #[case("fe80::", true)]
    #[case("fe80::1", true)]
    #[case("fd80::1", false)]
    #[case("2001:dead:beef:dead:beef:dead:beef:dead", false)]
    fn test_link_local_gid(#[case] ip_str: &str, #[case] expected: bool) {
        let ip = Ipv6Addr::from_str(ip_str).unwrap();

        let gid: Gid = ip.into();

        assert_eq!(expected, gid.is_unicast_link_local())
    }

    #[rstest]
    #[case([0xfe, 0x80, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad], "fe80:dead:beef:dead:beef:dead:beef:dead")]
    #[case([0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], "fe80:0000:0000:0000:0000:0000:0000:0000")]
    fn test_from_ibv_gid(#[case] octets: [u8; 16], #[case] expected: &str) {
        let gid_ = ibv_gid { raw: octets };
        let gid = Gid::from(gid_);
        assert_eq!(format!("{gid}"), expected);
    }

    #[test]
    fn test_global_routing_header_read() {
        let src_gid = Gid::from(Ipv6Addr::from_str("fe80::1").unwrap());
        let dst_gid = Gid::from(Ipv6Addr::from_str("fe80::2").unwrap());

        // Build raw bytes: version=6, traffic_class=0x12, flow_label=0x34567
        let mut raw = vec![0u8; GRH_HEADER_LEN + 4]; // 4 bytes payload
        raw[0] = 0x61; // version=6, traffic_class high nibble=1
        raw[1] = 0x23; // traffic_class low nibble=2, flow_label high nibble=3
        raw[2] = 0x45; // flow_label
        raw[3] = 0x67; // flow_label
        raw[4] = 0x00; // payload length high byte
        raw[5] = 0x04; // payload length low byte = 4
        raw[6] = 0x1b; // next header
        raw[7] = 0x40; // hop limit
        raw[8..24].copy_from_slice(&src_gid.raw);
        raw[24..40].copy_from_slice(&dst_gid.raw);
        raw[40..44].copy_from_slice(&[0xde, 0xad, 0xbe, 0xef]); // payload

        let header = GlobalRoutingHeader::new_checked(raw.as_slice()).unwrap();
        assert_eq!(header.version(), 6);
        assert_eq!(header.traffic_class(), 0x12);
        assert_eq!(header.flow_label(), 0x34567);
        assert_eq!(header.payload_length(), 4);
        assert_eq!(header.next_header(), 0x1b);
        assert_eq!(header.hop_limit(), 0x40);
        assert_eq!(header.source_gid(), src_gid);
        assert_eq!(header.destination_gid(), dst_gid);
    }

    #[test]
    fn test_global_routing_header_write() {
        let src_gid = Gid::from(Ipv6Addr::from_str("fe80::1").unwrap());
        let dst_gid = Gid::from(Ipv6Addr::from_str("fe80::2").unwrap());

        let mut raw = vec![0u8; GRH_HEADER_LEN];
        let mut header = GlobalRoutingHeader::new_checked(raw.as_mut_slice()).unwrap();

        header.setup_version(6);
        header.setup_traffic_class(0x12);
        header.setup_flow_label(0x34567);
        header.setup_payload_length(100);
        header.setup_next_header(0x1b);
        header.setup_hop_limit(64);
        header.setup_source_gid(&src_gid);
        header.setup_destination_gid(&dst_gid);

        // Verify by reading back
        let header = GlobalRoutingHeader::new_unchecked(raw.as_slice());
        assert_eq!(header.version(), 6);
        assert_eq!(header.traffic_class(), 0x12);
        assert_eq!(header.flow_label(), 0x34567);
        assert_eq!(header.payload_length(), 100);
        assert_eq!(header.next_header(), 0x1b);
        assert_eq!(header.hop_limit(), 64);
        assert_eq!(header.source_gid(), src_gid);
        assert_eq!(header.destination_gid(), dst_gid);
    }

    #[test]
    fn test_global_routing_header_check_len_error() {
        let raw = vec![0u8; GRH_HEADER_LEN - 1];
        let err = GlobalRoutingHeader::new_checked(raw.as_slice()).unwrap_err();

        match err {
            GlobalRoutingHeaderError::SliceTooSmall { actual, expected } => {
                assert_eq!(actual, GRH_HEADER_LEN - 1);
                assert_eq!(expected, GRH_HEADER_LEN);
            },
        }
    }

    #[test]
    fn test_global_routing_header_to_ibv_grh() {
        let src_gid = Gid::from(Ipv6Addr::from_str("fe80::1").unwrap());
        let dst_gid = Gid::from(Ipv6Addr::from_str("fe80::2").unwrap());

        let mut raw = vec![0u8; GRH_HEADER_LEN];
        let mut header = GlobalRoutingHeader::new_unchecked(raw.as_mut_slice());
        header.setup_version(6);
        header.setup_traffic_class(0);
        header.setup_flow_label(1);
        header.setup_payload_length(0x1234);
        header.setup_next_header(0x1b);
        header.setup_hop_limit(0x40);
        header.setup_source_gid(&src_gid);
        header.setup_destination_gid(&dst_gid);

        let header = GlobalRoutingHeader::new_unchecked(raw.as_slice());
        let grh = header.grh();

        // Verify the ibv_grh fields
        assert_eq!(u32::from_be(grh.version_tclass_flow) >> 28, 6); // version
        assert_eq!(u32::from_be(grh.version_tclass_flow) & 0x000f_ffff, 1); // flow_label
        assert_eq!(u16::from_be(grh.paylen), 0x1234);
        assert_eq!(grh.next_hdr, 0x1b);
        assert_eq!(grh.hop_limit, 0x40);
        assert_eq!(Gid::from(grh.sgid), src_gid);
        assert_eq!(Gid::from(grh.dgid), dst_gid);
    }
}
